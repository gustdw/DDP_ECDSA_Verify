/*
 * montgomery.c
 *
 */

#include "montgomery.h"
#include <string.h>

#define WORD_SIZE 32

void add(uint32_t *t, uint32_t i, uint32_t C) {
    uint64_t sum = 0;
    uint32_t S;
    while (C!=0) {
        sum = t[i] + C;
        S = (uint32_t)sum;
        C = (uint32_t)(sum >> WORD_SIZE);
        t[i] = S;
        i++;
    }
}

void sub_cond(uint32_t *u, uint32_t *n, uint32_t size) {
    uint32_t B = 0;
    uint32_t t[size+1] = {0;
    uint32_t sub = 0;
    for (uint32_t i = 0; i<=size; i++) {
        sub = u[i] - n[i] - B;
        if (u[i] >= n[i] + B) {
            B = 0;
        } else {
            B = 1;
        }
        t[i] = sub;
    }
    if (B == 0) {
        memcpy(u, t, (size-1)*sizeof(uint32_t));
    } else {
        return;
    }
}

// Calculates res = a * b * r^(-1) mod n.
// a, b, n, n_prime represent operands of size elements
// res has (size+1) elements
// FIPS
void montMul(uint32_t *a, uint32_t *b, uint32_t *n, uint32_t *n_prime, uint32_t *res, uint32_t size)
{
    uint32_t t[3] = {0};
    uint32_t w = 32;
    uint64_t sum = 0;
    for (uint32_t i = 0; i < size; i++) {
        uint32_t C, S;
        for (uint32_t j = 0; j<i; j++) {
            sum = t[0] + a[j] * b[i-j];
            S = (uint32_t)sum;
            C = (uint32_t)(sum >> WORD_LENGTH);
            add(t, 1, C);
            sum = S + res[j] * n[i-j];
            S = (uint32_t)sum;
            C = (uint32_t)(sum >> WORD_LENGTH);
            t[0] = S;
            add(t, 1, C);
        }
        sum = t[0] + a[i] * b[0];
        S = (uint32_t)sum;
        C = (uint32_t)(sum >> w);
        add(t, 1, C);
        res[i] = (uint32_t)(S*(*n_prime));
        sum = S + res[i] * n[0];
        S = (uint32_t)sum;
        C = (uint32_t)(sum >> w);
        add(t, 1, C);
        t[0] = t[1];
        t[1] = t[2];
        t[2] = 0;
    }
    for (uint32_t i = size; i<2*size; i++) {
        uint32_t C, S;
        for (uint32_t j = i-size+1; j<size; j++) {
            sum = t[0] + a[j] * b[i-j];
            S = (uint32_t)sum;
            C = (uint32_t)(sum >> w);
            add(t, 1, C);
            sum = S + res[j] * n[i-j];
            S = (uint32_t)sum;
            C = (uint32_t)(sum >> w);
            t[0] = S;
            add(t, 1, C);
        }
        res[i-size] = t[0];
        t[0] = t[1];
        t[1] = t[2];
        t[2] = 0;
    }
    res[size] = t[0];
    sub_cond(res, n, size);
}

// Calculates res = a * b * r^(-1) mod n.
// a, b, n, n_prime represent operands of size elements
// res has (size+1) elements
// Optimised ASM version
void montMulOpt(uint32_t *a, uint32_t *b, uint32_t *n, uint32_t *n_prime, uint32_t *res, uint32_t size)
{

}
