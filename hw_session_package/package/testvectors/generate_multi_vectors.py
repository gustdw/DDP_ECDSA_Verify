import sys
import random
import os

# Import your existing modules
# We assume helpers.py, curves.py, and SW.py are in the python path
try:
    import helpers
    import curves
    import SW
except ImportError as e:
    print(f"Error importing required modules: {e}")
    print("Ensure helpers.py, curves.py, and SW.py are in the same directory.")
    sys.exit(1)

def write_constants_string(number, size=32):
    """
    Formats a number into a comma-separated hex string, 
    matching the logic in helpers.py (little-endian chunks).
    """
    out = ''
    for i in range(size):
        # Mask lower 32 bits
        chunk = number & 0xFFFFFFFF
        out += '0x{:08x}'.format(chunk)
        # Shift down
        number >>= 32
        out += ', ' if i < (size - 1) else ''
    return out

def generate_header(f, num_vectors, seed_start):
    f.write("#include <stdint.h>\n")
    f.write("#include <stdalign.h>\n\n")
    f.write(f"#define NUM_TEST_VECTORS {num_vectors}\n")
    f.write(f"// Generated by generate_multi_vectors.py\n")
    f.write(f"// Starting Seed: {seed_start}\n\n")

def generate_single_vector(seed_val):
    """
    Runs the ECDSA logic from testvectors.py (Operation 6)
    Returns a dictionary of results.
    """
    helpers.setSeed(seed_val)
    
    # 1. Setup Parameters (Logic adapted from testvectors.py op 6)
    G = helpers.affineToProjective(curves.G)
    private_key = helpers.getRandomInt(255) % curves.groupOrder
    
    # 2. Compute public key P = p * G
    public_key = SW.EC_scalar_mult(private_key, G)
    
    # 3. Create message hash
    message = helpers.getRandomInt(255) % curves.groupOrder
    
    # 4. Sign the message
    signature = SW.ecdsa_sign(private_key, message)
    K, s = signature
    
    # 5. Verify the signature (to get C, C_prime, r)
    verify_result = SW.ecdsa_verify(message, signature, public_key)
    valid, C, C_prime, r = verify_result
    
    if not valid:
        print(f"WARNING: Generated vector for seed {seed_val} is INVALID.")

    # Return all necessary data
    return {
        "message": message,
        "K": K, # (x,y,z)
        "s": s,
        "public_key": public_key, # (x,y,z)
        "C": C,
        "C_prime": C_prime,
        "r": r
    }

def write_2d_array(f, name, data_list, key_selector, shift=643):
    """
    Writes a 2D C array.
    data_list: list of dictionaries from generate_single_vector
    key_selector: function to extract the specific value from the dict
    shift: The bitshift applied in helpers.py (seems to be 643 based on your files)
    """
    f.write(f"alignas(128) uint32_t {name}[NUM_TEST_VECTORS][32] = {{\n")
    
    for i, data in enumerate(data_list):
        value = key_selector(data)
        # Apply the specific shift found in your helpers.py
        value_shifted = value << shift
        hex_str = write_constants_string(value_shifted, 32)
        
        f.write(f"    {{ {hex_str} }}")
        if i < len(data_list) - 1:
            f.write(",\n")
        else:
            f.write("\n")
            
    f.write("};\n\n")

def write_constants(f, modulus, G):
    """
    Writes constant values that don't change between vectors (Modulus, Generator, R constants).
    """
    shift = 643
    
    # Precompute R constants
    R = 2**381
    R_N = R % modulus
    R2_N = (R*R) % modulus

    # Write Modulus (Single array)
    f.write(f"// Constants (Shared across all vectors)\n")
    f.write(f"alignas(128) uint32_t modulus[32]   = {{ {write_constants_string(modulus << shift)} }};\n")
    
    # Write Generator G (Single arrays)
    f.write(f"alignas(128) uint32_t G_X[32]       = {{ {write_constants_string(G[0] << shift)} }};\n")
    f.write(f"alignas(128) uint32_t G_Y[32]       = {{ {write_constants_string(G[1] << shift)} }};\n")
    f.write(f"alignas(128) uint32_t G_Z[32]       = {{ {write_constants_string(G[2] << shift)} }};\n")

    # Write R constants (Single arrays)
    f.write(f"alignas(128) uint32_t R_N[32]       = {{ {write_constants_string(R_N << shift)} }};\n")
    f.write(f"alignas(128) uint32_t R2_N[32]      = {{ {write_constants_string(R2_N << shift)} }};\n\n")

def main():
    if len(sys.argv) < 2:
        print("Usage: python generate_multi_vectors.py <num_vectors> [start_seed]")
        sys.exit(1)

    try:
        num_vectors = int(sys.argv[1])
    except ValueError:
        print("Error: Number of vectors must be an integer.")
        sys.exit(1)

    start_seed = sys.argv[2] if len(sys.argv) > 2 else "2025.1"
    
    output_filename = "testvector_multi.c"
    
    print(f"Generating {num_vectors} test vectors starting from seed '{start_seed}'...")
    print(f"Output file: {output_filename}")

    # 1. Collect Data
    all_vectors = []
    
    # We rely on helpers.setSeed to interpret the seed. 
    # If the seed is a float-string like "2025.1", we can increment it or append index.
    # To be safe and simple, we append the index to the string base.
    
    for i in range(num_vectors):
        current_seed = f"{start_seed}_{i}"
        print(f"  - Generating vector {i+1}/{num_vectors} (Seed: {current_seed})")
        vector_data = generate_single_vector(current_seed)
        all_vectors.append(vector_data)

    # 2. Write File
    with open(output_filename, 'w') as f:
        generate_header(f, num_vectors, start_seed)
        
        # Write Static Constants (Modulus, G, etc)
        # We grab the modulus/G from the first vector (or curves directly)
        G_proj = helpers.affineToProjective(curves.G)
        write_constants(f, curves.q, G_proj)
        
        f.write("// Dynamic Test Vectors (Access via index [i])\n")
        
        # Write Message
        write_2d_array(f, "message", all_vectors, lambda d: d["message"])
        
        # Write Signature K (X, Y, Z)
        write_2d_array(f, "K_X", all_vectors, lambda d: d["K"][0])
        write_2d_array(f, "K_Y", all_vectors, lambda d: d["K"][1])
        write_2d_array(f, "K_Z", all_vectors, lambda d: d["K"][2])
        
        # Write Signature s
        write_2d_array(f, "s", all_vectors, lambda d: d["s"])
        
        # Write Public Key (X, Y, Z)
        write_2d_array(f, "Public_X", all_vectors, lambda d: d["public_key"][0])
        write_2d_array(f, "Public_Y", all_vectors, lambda d: d["public_key"][1])
        write_2d_array(f, "Public_Z", all_vectors, lambda d: d["public_key"][2])
        
        # Write Expected Outputs (C, C_Prime, r/K_X_Modn)
        write_2d_array(f, "C_X", all_vectors, lambda d: d["C"][0])
        write_2d_array(f, "C_Y", all_vectors, lambda d: d["C"][1])
        write_2d_array(f, "C_Z", all_vectors, lambda d: d["C"][2])
        
        write_2d_array(f, "C_Prime_X", all_vectors, lambda d: d["C_prime"][0])
        write_2d_array(f, "C_Prime_Y", all_vectors, lambda d: d["C_prime"][1])
        write_2d_array(f, "C_Prime_Z", all_vectors, lambda d: d["C_prime"][2])
        
        # Note: In testvectors.py/helpers.py, 'r' corresponds to variable 'K_X_Modn'
        write_2d_array(f, "K_X_Modn", all_vectors, lambda d: d["r"])

    print("Done! File generated successfully.")

if __name__ == "__main__":
    main()